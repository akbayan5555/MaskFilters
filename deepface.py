# -*- coding: utf-8 -*-
"""deepface.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MrobmoaAW8SWT3RoQzJvAMmMWfD2n8NX
"""

!pip install deepface opencv-python matplotlib

!pip install mediapipe opencv-python numpy

!pip install --upgrade numpy==1.23.5

!pip uninstall -y mediapipe opencv-python
!pip install mediapipe opencv-python numpy==1.23.5

import cv2
import numpy as np
import mediapipe as mp
from google.colab.patches import cv2_imshow

# Инициализация FaceMesh из MediaPipe
mp_face_mesh = mp.solutions.face_mesh

def get_face_landmarks(image):
    """ Возвращает координаты ключевых точек лица с помощью MediaPipe. """
    with mp_face_mesh.FaceMesh(static_image_mode=True, max_num_faces=1) as face_mesh:
        results = face_mesh.process(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        if results.multi_face_landmarks:
            return results.multi_face_landmarks[0].landmark
    return None

def overlay_faces(source_img, target_img):
    """ Накладывает лицо из source_img на лицо из target_img. """

    # Проверяем, загрузились ли изображения
    if source_img is None or target_img is None:
        print("Ошибка: одно или оба изображения не загружены. Проверьте пути.")
        return

    # Изменяем размер source_img до размеров target_img
    source_img = cv2.resize(source_img, (target_img.shape[1], target_img.shape[0]))

    # Получаем ключевые точки лиц
    source_landmarks = get_face_landmarks(source_img)
    target_landmarks = get_face_landmarks(target_img)

    if source_landmarks is None or target_landmarks is None:
        print("Ошибка: не удалось обнаружить лица на одном из изображений.")
        return

    # Создаём маску для области лица
    mask = np.zeros_like(target_img, dtype=np.uint8)
    hull = np.array([[int(target_landmarks[i].x * target_img.shape[1]),
                      int(target_landmarks[i].y * target_img.shape[0])] for i in range(468)], np.int32)
    cv2.fillConvexPoly(mask, hull, (255, 255, 255))

    # Копируем лицо из source_img и накладываем на target_img
    transformed_face = cv2.bitwise_and(source_img, mask)
    blended = cv2.addWeighted(target_img, 0.5, transformed_face, 0.5, 0)

    # Отображаем результат
    cv2_imshow(blended)

# Укажите пути к загруженным изображениям в Google Colab
source_img = cv2.imread("/content/5.jpg")  # Лицо, которое накладываем
target_img = cv2.imread("/content/3.jpg")  # Лицо, на которое накладываем

# Запускаем наложение
overlay_faces(source_img, target_img)

!pip install dlib opencv-python numpy imutils

import cv2
import dlib
import numpy as np
from google.colab.patches import cv2_imshow  # ✅ Для отображения изображений в Colab

# Проверяем, есть ли файл модели
import os
if not os.path.exists("/content/shape_predictor_68_face_landmarks.dat"):
    raise FileNotFoundError("Файл shape_predictor_68_face_landmarks.dat не найден! Скачайте и поместите его в /content/.")

# Загрузка предобученной модели dlib
detector = dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor("/content/shape_predictor_68_face_landmarks.dat")

# Функция для извлечения ключевых точек лица
def get_face_landmarks(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = detector(gray)

    if len(faces) == 0:
        raise ValueError("Лицо не найдено! Попробуйте другое изображение.")

    landmarks = predictor(gray, faces[0])
    points = np.array([(landmarks.part(n).x, landmarks.part(n).y) for n in range(68)], dtype=np.int32)
    return points

# Функция для наложения лица
def swap_faces(source_img, target_img):
    source_points = get_face_landmarks(source_img)
    target_points = get_face_landmarks(target_img)

    hull_source = cv2.convexHull(source_points).reshape(-1, 2)
    hull_target = cv2.convexHull(target_points).reshape(-1, 2)

    mask = np.zeros_like(target_img, dtype=np.uint8)
    cv2.fillConvexPoly(mask, hull_target, (255, 255, 255))

    # Приведение размеров изображений к одинаковым
    source_img = cv2.resize(source_img, (target_img.shape[1], target_img.shape[0]))
    mask = cv2.resize(mask, (source_img.shape[1], source_img.shape[0]))

    # Вырезаем лицо
    face_region = cv2.bitwise_and(source_img, mask)

    # Накладываем лицо с прозрачностью
    blended = cv2.addWeighted(target_img, 0.7, face_region, 0.3, 0)

    return blended

# Загружаем изображения
source_img = cv2.imread("/content/6.jpg")  # Исходное лицо
target_img = cv2.imread("/content/4.jpg")  # Лицо, на которое накладываем

# Проверяем, загружены ли изображения
if source_img is None or target_img is None:
    raise ValueError("Ошибка загрузки изображений. Проверь пути к файлам!")

# Запускаем замену лица
result = swap_faces(source_img, target_img)

# ✅ Показываем результат в Colab
cv2_imshow(result)

# ✅ Сохраняем и даём возможность скачать
cv2.imwrite("/content/swapped_face.jpg", result)
from google.colab import files
files.download("/content/swapped_face.jpg")

import cv2
import dlib
import numpy as np
from google.colab.patches import cv2_imshow
import os

if not os.path.exists("/content/shape_predictor_68_face_landmarks.dat"):
    raise FileNotFoundError("Файл shape_predictor_68_face_landmarks.dat not found!")
detector = dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor("/content/shape_predictor_68_face_landmarks.dat")

def get_face_landmarks(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = detector(gray)
    if len(faces) == 0:
        raise ValueError("Mistakes")
    landmarks = predictor(gray, faces[0])
    points = np.array([(landmarks.part(n).x, landmarks.part(n).y) for n in range(68)], dtype=np.int32)
    return points
def delaunay_triangulation(points, size):
    rect = (0, 0, size[1], size[0])
    subdiv = cv2.Subdiv2D(rect)
    for p in points:
        subdiv.insert(tuple(map(int, p)))
    triangles = subdiv.getTriangleList()
    triangles = np.array(triangles, dtype=np.int32)
    delaunay_indices = []
    for t in triangles:
        pts = []
        for i in range(0, 6, 2):
            pt = (t[i], t[i+1])
            idx = np.argmin(np.linalg.norm(points - pt, axis=1))
            pts.append(idx)
        delaunay_indices.append(pts)
    return np.array(delaunay_indices)
def swap_faces(source_img, target_img):
    source_points = get_face_landmarks(source_img)
    target_points = get_face_landmarks(target_img)
    triangles = delaunay_triangulation(target_points, target_img.shape)
    mask = np.zeros_like(target_img, dtype=np.uint8)
    hull = cv2.convexHull(target_points)
    cv2.fillConvexPoly(mask, hull, (255, 255, 255))
    warped_source = np.zeros_like(target_img)
    for tri in triangles:
        pts_source = np.float32([source_points[tri[0]], source_points[tri[1]], source_points[tri[2]]])
        pts_target = np.float32([target_points[tri[0]], target_points[tri[1]], target_points[tri[2]]])
        M = cv2.getAffineTransform(pts_source, pts_target)
        warped_triangle = cv2.warpAffine(source_img, M, (target_img.shape[1], target_img.shape[0]))
        mask_triangle = np.zeros_like(target_img, dtype=np.uint8)
        cv2.fillConvexPoly(mask_triangle, np.int32(pts_target), (255, 255, 255))
        warped_source = cv2.bitwise_and(warped_source, cv2.bitwise_not(mask_triangle))
        warped_source += cv2.bitwise_and(warped_triangle, mask_triangle)
    center = (target_points[:, 0].mean().astype(int), target_points[:, 1].mean().astype(int))
    seamless = cv2.seamlessClone(warped_source, target_img, mask, center, cv2.NORMAL_CLONE)
    return seamless

source_img = cv2.imread("/content/4.jpg")  # first face
target_img = cv2.imread("/content/11.jpg")  # second face

if source_img is None or target_img is None:
    raise ValueError("mistake wuth import!")
result = swap_faces(source_img, target_img)
cv2_imshow(result)
cv2.imwrite("/content/swapped_face.jpg", result)
from google.colab import files
files.download("/content/swapped_face.jpg")